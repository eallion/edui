<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>不会消失的点 ｜ Dots that won't quit</title>
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../style.css" />
  </head>

  <body class="illusion">
    <div class="wrapper">
      <div class="optical-toy themeB">
        <div class="menu">
          <div class="mainMenu">
            <h2><a href="/cuojue">光学玩具</a></h2>
            <h3>不会消失的点</h3>
          </div>

          
          <div class="submenu">
            <a href="../healing-grid/">下一个错觉 ›</a>
          </div>
          
          <div class="submenu fit"><a href="#about">👇了解更多</a></div>
        </div>

        <div class="the-toy">
          <canvas id="canvas" class=""></canvas>
        </div>
        <div class="instructions">
          <div class="how-and-what">
            <h2>如何/什么?</h2>
            <p>这个名字对你来说应该足够了！这是一个迷幻的，你能数一下有多少个点吗？</p>
          </div>
          <div class="controls"></div>
        </div>
      </div>
    </div>

    <div id="about" class="about">
      <p><strong>内容:</strong>虽然我仍然觉得“不会退出的点”是一个更好的名字，但这种错觉实际上被称为闪烁网格错觉，由 Elke Lingelbach 于 1994 年发现，尽管它也属于赫尔曼网格错觉的范畴 （我还没有建立这个，但将来会建立！）效果简单而强大，你会看到交叉圆圈中出现了黑点，而它们并不存在！</p>

      <p><strong>操作:</strong>您可以自定义颜色并实现不同程度的这种效果，例如，它们在翻转时起作用，您会看到光点。您可以调整颜色和大小，并准确查看它与哪些对比集配合使用。对我来说，非常小的尺寸仍然非常有效，绝对没有机会数那些点。</p>

      <p><strong>解释:</strong>目前似乎有一些讨论到底是什么导致了之前的理解，即你的感受野错误地计算了浅色和深色。然而，麻省理工学院的那些聪明人提出了不同的建议。我不是权威，也很难理解任何解释，但请随意进入兔子洞。总而言之，我认为我们仍然不清楚确切的原因（用你的大脑来研究你的大脑很难！）</p>

    <script src="../js/tweakpane.min.js"></script>
       
    <script>
      const wrapper=document.querySelector('.the-toy');let stripeDistance=90,stripeWidth=13,backgroundColor='#272A2E',stripeColor="#8E8E8E",dotColor="white";function draw(){const a=document.getElementById("canvas"),b=a.getContext("2d");a.width=wrapper.clientWidth,a.height=wrapper.clientHeight;const c=stripeWidth/2+2;let d=stripeDistance-a.width%stripeDistance/2+stripeWidth/2,e=stripeDistance-a.height%stripeDistance/2+stripeWidth/2;b.fillStyle=backgroundColor,b.fillRect(0,0,a.width,a.height),b.fillStyle=stripeColor;for(let c=-e;c<=a.height;c+=stripeDistance)b.fillRect(0,c,a.width,stripeWidth);for(let c=-d;c<=a.width;c+=stripeDistance)b.fillRect(c,0,stripeWidth,a.height);b.fillStyle=dotColor;for(let f=-d;f<a.width;f+=stripeDistance)for(let d=-e;d<a.height;d+=stripeDistance)b.beginPath(),b.arc(f+c-2,d+c-2,c,0,2*Math.PI),b.fill()}draw();let controlParams={'Grid Width':stripeDistance,'Stripe Width':stripeWidth,'Stripe Color':stripeColor,'Background Color':backgroundColor,'Dot Color':dotColor};const pane=new Tweakpane.Pane({container:document.querySelector('.controls')}),controls=pane.addFolder({title:'自定义',expanded:!1});controls.addInput(controlParams,'Grid Width',{min:30,max:250,step:1}).on('change',a=>{stripeDistance=a.value,draw()}),controls.addInput(controlParams,'Stripe Width',{min:5,max:40,step:1}).on('change',a=>{stripeWidth=a.value,draw()}),controls.addInput(controlParams,'Stripe Color',{picker:'inline',expanded:!0}).on('change',a=>{stripeColor=a.value,draw()}),controls.addInput(controlParams,'Background Color',{picker:'inline',expanded:!0}).on('change',a=>{backgroundColor=a.value,draw()})
    </script>
    
</body>
</html>