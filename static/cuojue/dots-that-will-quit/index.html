<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>将退出的点 ｜ Dots that will quit</title>
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../style.css" />
  </head>

  <body class="illusion">
    <div class="wrapper">
      <div class="optical-toy themeA">
        <div class="menu">
          <div class="mainMenu">
            <h2><a href="/cuojue">光学玩具</a></h2>
            <h3>将退出的点</h3>
          </div>

          
          <div class="submenu">
            <a href="../dots-that-wont-quit/">下一个错觉 ›</a>
          </div>
          
          <div class="submenu fit"><a href="#about">👇了解更多</a></div>
        </div>

        <div class="the-toy">
          <canvas id="canvas" class=""></canvas>
        </div>
        <div class="instructions">
          <div class="how-and-what">
            <h2>如何/什么?</h2>
            <p>专注于一个点，其余的就会消失。</p>
          </div>
          <div class="controls"></div>
        </div>
      </div>
    </div>

    <div id="about" class="about">
      <p><strong>内容:</strong>有些点会留下来，而另一些点则会消失，或者至少在这个幻觉中是这样的，这个幻觉被奇妙地命名为“灭绝幻觉”，由其创造者雅克·尼尼奥命名……在这个光学玩具中，当你聚焦一个点时你会看到（或没有看到？）其他较暗的点消失了，虽然这违背了我的直觉，但它在这里被命名为赫尔曼网格的变体</p>

      <p><strong>操作:</strong>您可以或多或少地定制整个事情！对我来说，线条的粗细是使幻觉更加强烈以及形成对比的关键部分，但你也会发现某些颜色冲突也能使其发挥作用。您还会发现区域之间的距离非常重要。</p>

      <p><strong>解释:</strong>如果这与赫尔曼网格类似，那么“如何”相对不确定，也就是说，这种幻觉给人的感觉与 Troxler Fade 没有什么不同，因为大脑专注于单一刺激，所以一些信息会丢失。</p>

    <script src="../js/tweakpane.min.js"></script>
       
    <script>
      const canvas=document.getElementById("canvas"),ctx=canvas.getContext("2d"),distance=90,thickness=10,lineColor="#888",dotColor="black",dotOutlineColor="white",radius=10,edgePadding=20;canvas.width=window.innerWidth,canvas.height=window.innerHeight,ctx.fillStyle="white",ctx.fillRect(0,0,canvas.width,canvas.height);const dotDistance=distance*4,numDotsX=Math.floor((canvas.width-2*edgePadding)/dotDistance),numDotsY=Math.floor((canvas.height-2*edgePadding)/dotDistance),gridWidth=numDotsX*dotDistance+distance,gridHeight=numDotsY*dotDistance+distance,xOffset=(canvas.width-gridWidth)/2+distance/2,yOffset=(canvas.height-gridHeight)/2+distance/2;for(let a=xOffset-distance*2;a<canvas.width;a+=distance)ctx.beginPath(),ctx.moveTo(a,0),ctx.lineTo(a,canvas.height),ctx.lineWidth=thickness,ctx.strokeStyle=lineColor,ctx.stroke();for(let a=yOffset-distance*2;a<canvas.height;a+=distance)ctx.beginPath(),ctx.moveTo(0,a),ctx.lineTo(canvas.width,a),ctx.lineWidth=thickness,ctx.strokeStyle=lineColor,ctx.stroke();for(let a=xOffset-distance*2;a<canvas.width;a+=distance){let b=(a-xOffset)/distance%2===0;for(let c=yOffset-distance*4;c<canvas.height;c+=distance)b?(ctx.beginPath(),ctx.moveTo(a,c),ctx.lineTo(a+distance,c+distance),ctx.lineWidth=thickness,ctx.strokeStyle=lineColor,ctx.stroke()):(ctx.beginPath(),ctx.moveTo(a+distance,c),ctx.lineTo(a,c+distance),ctx.lineWidth=thickness,ctx.strokeStyle=lineColor,ctx.stroke()),b=!b,(a-xOffset)/distance%4===0&&(c-yOffset)/distance%4===0&&(ctx.fillStyle=dotColor,ctx.strokeStyle=dotOutlineColor,ctx.lineWidth=2,ctx.beginPath(),ctx.arc(a,c,radius,0,Math.PI*2),ctx.fill(),ctx.stroke())}
    </script>
    
</body>
</html>