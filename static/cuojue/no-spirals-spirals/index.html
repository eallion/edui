<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>螺旋但不是 ｜ Spirals but not</title>
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../style.css" />
  </head>

  <body class="illusion">
    <div class="wrapper">
      <div class="optical-toy themeB">
        <div class="menu">
          <div class="mainMenu">
            <h2><a href="/cuojue">光学玩具</a></h2>
            <h3>螺旋但不是</h3>
          </div>
          
          <div class="submenu fit"><a href="#about">👇了解更多</a></div>
        </div>

        <div class="the-toy">
          <canvas id="canvas" class=""></canvas>
        </div>
        <div class="instructions">
          <div class="how-and-what">
            <h2>如何/什么?</h2>
            <p>在这里，感觉就像您在看螺旋，但事实并非如此，它们只是圆形......棘手！</p>
          </div>
          <div class="controls"></div>
        </div>
      </div>
    </div>

    <div id="about" class="about">
      <p><strong>内容:</strong>这种错觉的真正名称是交织错觉，由 Baingio Pinna 博士于 2002 年记录，是我在光学玩具中重新编码的第一个 Pinna 错觉，也是我个人最喜欢的。如果你还没有意识到这一点，那么这个错觉是一系列同心圆，是的，同心的，而且根本不是螺旋。</p>

      <p><strong>操作:</strong>这里有一些巧妙的东西可以玩，主要是你可以改变角度来看看什么时候幻觉对你来说最强，什么时候它完全打破……你会注意到，方块和背景的颜色也是如此。对比是使其更强的关键！</p>

      <p><strong>解释:</strong>如果您在自定义工具中使用颜色，您会发现对比度是这里关键的一部分，虽然我无法访问引用的论文，但一些细读告诉我这是您的外围设备视觉（真正让你产生错觉的地方）正在追踪正方形的角度并猜测这些形状是螺旋形的，然后这会让你以这种方式感知它，即使你知道它们不是螺旋形的。</p>

    <script src="../js/tweakpane.min.js"></script>
       
    <script>
      const canvas=document.getElementById("canvas"),ctx=canvas.getContext("2d");canvas.width=window.innerWidth,canvas.height=window.innerHeight;const circles=[64,48,36,18];let boxSize=18,gap=58,rotationAmount=15,bgColor='rgb(48, 62, 78)',squareAColor='#E4C75D',squareBColor='#ffffff';function draw(){let a=1;ctx.fillStyle=bgColor,ctx.fillRect(0,0,canvas.width,canvas.height);for(let b=0;b<circles.length;b++){const c=circles[b],e=360/c;let d=squareAColor;for(let f=1;f<=c;f++){const m=canvas.width/2,j=canvas.height/2,h=f*e,i=(boxSize+gap)*(circles.length-b),k=m+i*Math.cos(h*Math.PI/180),l=j+i*Math.sin(h*Math.PI/180);ctx.save(),ctx.translate(k,l),ctx.rotate((h+a*rotationAmount)*Math.PI/180),ctx.translate(-boxSize/2,-boxSize/2);const g=Math.round(f/c*255),n=`rgb(${g},${g},${g})`;ctx.beginPath(),ctx.rect(0,0,boxSize,boxSize),ctx.lineWidth=2,ctx.fillStyle=n,ctx.strokeStyle=d,ctx.stroke(),ctx.restore(),d=d===squareBColor?squareAColor:squareBColor}a=-a}}draw();let controlParams={Size:boxSize,Gap:gap,Rotation:rotationAmount,'Background Color':bgColor,'Square Color A':squareAColor,'Square Color B':squareBColor};const pane=new Tweakpane.Pane({container:document.querySelector('.controls')}),controls=pane.addFolder({title:'自定义',expanded:!1});controls.addInput(controlParams,'Size',{min:5,max:90}).on('change',a=>{boxSize=a.value,draw()}),controls.addInput(controlParams,'Gap',{min:10,max:150}).on('change',a=>{gap=a.value,draw()}),controls.addInput(controlParams,'Rotation',{min:1,max:90}).on('change',a=>{rotationAmount=a.value,draw()}),controls.addInput(controlParams,'Background Color',{picker:'inline',expanded:!0}).on('change',a=>{bgColor=a.value,draw()}),controls.addInput(controlParams,'Square Color A',{picker:'inline',expanded:!0}).on('change',a=>{squareAColor=a.value,draw()}),controls.addInput(controlParams,'Square Color B',{picker:'inline',expanded:!0}).on('change',a=>{squareBColor=a.value,draw()})
    </script>
    
</body>
</html>