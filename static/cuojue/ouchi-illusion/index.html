<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#000000" />
    <title>大内错觉 ｜ Ouchi Illusion</title>
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="stylesheet" href="../style.css" />
  </head>

  <body class="illusion">
    <div class="wrapper">
      <div class="optical-toy themeA">
        <div class="menu">
          <div class="mainMenu">
            <h2><a href="/cuojue">光学玩具</a></h2>
            <h3>大内错觉</h3>
          </div>

          
          <div class="submenu">
            <a href="../straight-line-squares/">下一个错觉 ›</a>
          </div>
          
          <div class="submenu fit"><a href="#about">👇了解更多</a></div>
        </div>

        <div class="the-toy">
          <canvas id="canvas" class=""></canvas>
        </div>
        <div class="instructions">
          <div class="how-and-what">
            <h2>如何/什么?</h2>
            <p>好吧，事实证明你的大脑不能很好地观察不同角度的矩形，并创建了一个浮动圆盘。</p>
          </div>
          <div class="controls"></div>
        </div>
      </div>
    </div>

    <div id="about" class="about">
      <p><strong>内容:</strong>大内错觉是一种以其发明者、日本图形艺术家 Hajime Ouchi 命名的错觉，于 1977 年，您会注意到中心的圆盘似乎悬停在背景上方，并且当您移动头部时它看起来似乎在轻微移动，而实际上我们知道它是静态的且是一个固定的 2D 圆。

      </p>

      <p><strong>操作:</strong>您可以通过增加对比色（黑色和白色是原始艺术家的设计）来提高这一强度，也可以更改矩形的长度和高度，对我来说，当它们很短时而长（或长与短）的幻觉最为强烈。另外，如果我稍微上下滚动（添加一点动作），它会导致效果更强。</p>

      <p><strong>解释:</strong>仔细阅读并阅读了几篇论文，这让我比开始时更加困惑，尽管我最终找到了一个很好的描述：</p>

      <blockquote>
        <p>这种错觉是由随机眼球运动引起的，眼球运动在水平和垂直方向上是独立的。然而，图中的两种类型的图案几乎消除了平行于每种类型的图案的眼球运动的影响。因此，受圆盘刺激的神经元传达的信号是圆盘由于眼球运动的水平分量而抖动，而受背景刺激的神经元传达的信号是运动是由于独立的垂直分量造成的。由于这两个区域独立抖动，因此大脑将这些区域解释为对应于单独的独立物体</p>
      </blockquote>

    <script src="../js/tweakpane.min.js"></script>
       
    <script>
      const canvas=document.getElementById("canvas");canvas.width=window.innerWidth,canvas.height=window.innerHeight;const ctx=canvas.getContext("2d");let lightColor="#f1c40f",darkColor="#2c3e50",bgRectWidth=40,bgRectHeight=15;function draw(){const b=bgRectHeight,c=bgRectWidth,a=Math.min(canvas.width,canvas.height)*.6,d=canvas.width/2-a/2,e=canvas.height/2-a/2,f=Math.ceil(a/c),g=Math.ceil(a/b);ctx.fillStyle=lightColor,ctx.fillRect(0,0,canvas.width,canvas.height);for(let a=0;a<canvas.height/bgRectHeight;a++)for(let b=0;b<canvas.width/bgRectWidth;b++){const c=b*bgRectWidth,d=a*bgRectHeight,e=(a+b)%2===0?lightColor:darkColor;ctx.fillStyle=e,ctx.fillRect(c,d,bgRectWidth,bgRectHeight)}ctx.save(),ctx.beginPath(),ctx.arc(d+a/2,e+a/2,a/2,0,Math.PI*2),ctx.clip(),ctx.fillStyle=darkColor,ctx.fillRect(d,e,a,a);for(let a=0;a<f;a++)for(let f=0;f<g;f++){const h=d+f*b,i=e+a*c,j=(a+f)%2===0?darkColor:lightColor;ctx.fillStyle=j,ctx.fillRect(h,i,b,c)}ctx.restore()}draw();let controlParams={'Rectangle Side A':bgRectWidth,'Rectangle Side B':bgRectHeight,'Color A':lightColor,'Color B':darkColor};const pane=new Tweakpane.Pane({container:document.querySelector('.controls')}),controls=pane.addFolder({title:'自定义',expanded:!1});controls.addInput(controlParams,'Rectangle Side A',{min:1,max:200,step:1}).on('change',a=>{bgRectWidth=a.value,draw()}),controls.addInput(controlParams,'Rectangle Side B',{min:1,max:200,step:1}).on('change',a=>{bgRectHeight=a.value,draw()}),controls.addInput(controlParams,'Color A',{picker:'inline',expanded:!0}).on('change',a=>{lightColor=a.value,draw()}),controls.addInput(controlParams,'Color B',{picker:'inline',expanded:!0}).on('change',a=>{darkColor=a.value,draw()})
    </script>
    
</body>
</html>